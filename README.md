# Assignment-4-Heap-Data-Structures

## Overview
As it has been implemented, the three fundamental algorithmic paradigms, sorting methods, a priority-based task handler based on a binary heap, and a chained hash table. Any component is aimed at demonstrating efficiency, scalability, and structural integrity with respect to varying input conditions. Study of the runtime behaviors. The sorting algorithms can be studied comparatively in terms of different data distributions. The task scheduler is designed such that it follows the priorities on the schedule according to urgency, as is done in real-world job management systems. The hash table design guarantees constant-time access with chaining, resolving the issues of key collisions. These implementations are altogether a convenient basis to interpret and judge the rudimentary design of algorithms.

## Running the Code
Each file when being executed will need a standard Python 3. The scripts are written without the use of external libraries except the ones that are built-in like heapq, time, random, and itertools. Each file has self-contained code which does some specific data structure or algorithmic job, but also has test cases.
In order to compare sorting algorithms, the script named Comparison.py must be run. The program tests Heapsort, Merge Sort, and inbuilt Quick Sort with various kinds of input arrays, such as randomly generated and sorted, and reverse-sorted lists. The execution time of every algorithm is reported against input sizes of a thousand, five thousand, and ten thousand elements.
In order to see the behavior of the priority queue using a binary min-heap, the Data Structure.py code must be run. This script establishes a task class and realizes operations of insertion, extraction, and update of priority of a heap-based scheduler. The output reflects the priority of task processing.
To exercise the hash table application, the Hash table.py script offers insert, delete, search, and display services on a hash table using chaining to resolve collisions. Executing the file shows the hash table contents consisting of the string keys after a series of operations is effected on them.

## Summary of Results
Running the sorting comparison, it is pointed out that Quicksort provides the fastest average in terms of sorting because it optimally guides the structure in the form of hybrid sorting, particularly when the data is sorted and random. Merge Sort maintains consistent performance due to its guaranteed O(n log n) complexity. Heapsort is also not the fastest algorithm, being slow most of the time when compared to the other two algorithms because it incurs more memory management overhead. The results of the performance of all sorting algorithms comply with the theoretical demands, and some differences are observed when they are tested on the different distributions.
The binary min-heap implemented to use as a task scheduler results in logarithmic insertion and extraction operations. The processing tasks are arranged in order of ascending priorities to provide timely practice of the high-priority jobs. The implementations comprise an update task priority feature that validates the usefulness of heap-based structures in situations of dynamic scheduling.
The hash table based on chaining is effective when it comes to accessing with a list-based collision management process. Insertion, search and deletion operations follow a constant-time behavior under a uniform distribution and manageable load factors. The theoretical analysis of the behaviour of chained hashing is confirmed with visualization of contents of the hash tables that revealing even distribution of the keys when hashed.
